name: Generate Documentation

on:
  workflow_run:
    workflows: ["Update Configs"]
    types:
      - completed
  workflow_dispatch:

permissions:
  contents: write

jobs:
  generate-docs:
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v6
        with:
          ref: ${{ github.ref }}
          fetch-depth: 0

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'

      - name: Install dependencies
        run: pip install pyyaml

      - name: Generate Sub-READMEs
        run: |
          python3 << 'PYTHON_SCRIPT'
          import os
          import urllib.parse
          import yaml
          
          yaml.add_multi_constructor("!", lambda loader, suffix, node: None, Loader=yaml.SafeLoader)

          REPO_URL = "https://github.com/${{ github.repository }}/blob/main"
          # ä¿®æ”¹ï¼šYAML æºç›®å½•æ˜ å°„åˆ° THEYAMLS
          DIR_MAP = {
              "THEYAMLS/Official_Examples": "Mihomo å®˜æ–¹ç¤ºä¾‹ (Official)",
              "THEYAMLS/General_Config": "é€šç”¨è¿›é˜¶é…ç½® (General Config)",
              "THEYAMLS/Smart_Mode": "Smart æ¨¡å¼ / è·¯ç”±ä¸“ç”¨ (Smart Mode)",
              "THEYAMLS/Mobile_Modules": "Android æ‰‹æœºæ¨¡å— (Mobile Modules)"
          }
          # å¿½ç•¥ Overwrite ç›®å½•ï¼Œé¿å…æ‰«æ THEINI/THEOPENCLASH ä¸­çš„é YAML æ–‡ä»¶
          IGNORE_DIRS = [".git", ".github", "Overwrite"]
          IGNORE_FILES = ["README.md", "LICENSE", "release_body.md"]

          def safe_get(data, keys, default="N/A"):
              val = data
              try:
                  for key in keys:
                      val = val[key]
                  return val
              except:
                  return default

          def get_file_size(path):
              try:
                  size = os.path.getsize(path)
                  if size < 1024: return f"{size} B"
                  return f"{size/1024:.1f} KB"
              except: return "Unknown"

          def read_file_content(file_path):
              content = ""
              try:
                  with open(file_path, "r", encoding="utf-8") as f:
                      content = f.read()
              except UnicodeDecodeError:
                  try:
                      with open(file_path, "r", encoding="gb18030", errors="ignore") as f:
                          content = f.read()
                  except Exception:
                      return None
              if "\t" in content:
                  content = content.replace("\t", "  ")
              return content

          def analyze_single_config(file_path):
              try:
                  raw_content = read_file_content(file_path)
                  if not raw_content: return None
                  data = yaml.safe_load(raw_content)
                  if not isinstance(data, dict): return None

                  info = {}
                  info["mode"] = safe_get(data, ["mode"], "Rule")
                  info["ipv6"] = "âœ…" if str(safe_get(data, ["ipv6"])).lower() == "true" else "ğŸš«"
                  info["allow_lan"] = "âœ…" if str(safe_get(data, ["allow-lan"])).lower() == "true" else "ğŸš«"
                  info["tun"] = "âœ… å¼€å¯" if safe_get(data, ["tun", "enable"], False) else "ğŸš« å…³é—­"
                  info["port_mixed"] = safe_get(data, ["mixed-port"], "-")
                  info["port_ctrl"] = safe_get(data, ["external-controller"], "-")
                  
                  ports_list = []
                  p_mix = data.get("mixed-port")
                  if p_mix: ports_list.append(f"| Mixed (æ··åˆ) | {p_mix} | HTTP/SOCKS |")
                  p_http = data.get("port")
                  if p_http: ports_list.append(f"| HTTP | {p_http} | ä»… HTTP |")
                  p_socks = data.get("socks-port")
                  if p_socks: ports_list.append(f"| SOCKS5 | {p_socks} | ä»… SOCKS |")
                  p_tproxy = data.get("tproxy-port")
                  if p_tproxy: ports_list.append(f"| TProxy | {p_tproxy} | é€æ˜ä»£ç† (UDP) |")
                  p_redir = data.get("redir-port")
                  if p_redir: ports_list.append(f"| Redirect | {p_redir} | é€æ˜ä»£ç† (TCP) |")
                  p_ctrl = data.get("external-controller")
                  if p_ctrl: ports_list.append(f"| Controller | {p_ctrl} | æ§åˆ¶é¢æ¿ |")

                  listeners = data.get("listeners", [])
                  if listeners and isinstance(listeners, list):
                      for l in listeners:
                          if isinstance(l, dict):
                              name = l.get("name", "Unknown")
                              port = l.get("port", "?")
                              l_type = l.get("type", "mixed")
                              ports_list.append(f"| ğŸ‘‚ {name} | {port} | {l_type} |")
                  
                  info["ports_display_lines"] = ports_list
                  groups = data.get("proxy-groups", [])
                  info["group_count"] = len(groups) if isinstance(groups, list) else 0
                  rules = data.get("rules", [])
                  info["rule_count"] = len(rules) if isinstance(rules, list) else 0
                  
                  info["groups_raw"] = []
                  if isinstance(groups, list):
                      for pg in groups:
                          if isinstance(pg, dict):
                              name = pg.get("name", "Unknown")
                              type_ = pg.get("type", "select")
                              icon = "ğŸš€"
                              if "auto" in type_ or "url-test" in type_: icon = "â™»ï¸"
                              elif "fallback" in type_: icon = "ğŸ”§"
                              elif "load-balance" in type_: icon = "âš–ï¸"
                              elif "select" in type_: icon = "ğŸ‘†"
                              info["groups_raw"].append(f"| {icon} {name} | `{type_}` |")

                  info["dns_raw"] = []
                  dns = data.get("dns", {})
                  if isinstance(dns, dict) and dns.get("enable", False):
                      nameservers = dns.get("nameserver", [])
                      if isinstance(nameservers, list):
                          for ns in nameservers:
                              if isinstance(ns, str):
                                  provider = "DoT" if "tls://" in ns else "DoH" if "https://" in ns else "UDP"
                                  info["dns_raw"].append(f"| {provider} | `{ns}` |")
                  
                  return info
              except Exception as e:
                  return None

          def generate_comparison_table(configs_data):
              headers = ["ç‰¹æ€§ / æ–‡ä»¶"] 
              for filename in configs_data.keys():
                  headers.append(f"`{filename}`")
              
              lines = []
              lines.append("| " + " | ".join(headers) + " |")
              lines.append("| :--- " + "| :--- " * len(configs_data) + "|")
              
              size_row = ["**æ–‡ä»¶å¤§å°**"]
              for filename, data in configs_data.items():
                  size_row.append(data.get("file_size", "N/A"))
              lines.append("| " + " | ".join(size_row) + " |")

              rows = [
                  ("port_mixed", "æ··åˆç«¯å£"),
                  ("port_ctrl", "æ§åˆ¶é¢æ¿"),
                  ("mode", "è¿è¡Œæ¨¡å¼"),
                  ("tun", "TUN æ¨¡å¼"),
                  ("group_count", "ç­–ç•¥ç»„æ•°"),
                  ("rule_count", "è§„åˆ™æ¡æ•°"),
              ]

              for key, label in rows:
                  row_content = [f"**{label}**"]
                  for filename, data in configs_data.items():
                      val = data.get("parsed", {}).get(key, "N/A")
                      if key in ["group_count", "rule_count"]:
                          val = f"**{val}**"
                      row_content.append(str(val))
                  lines.append("| " + " | ".join(row_content) + " |")
              
              return "\n".join(lines)

          def generate_readme(root_path, files):
              rel_path = os.path.relpath(root_path, ".")
              # æå– THEYAMLS/Category åé¢çš„éƒ¨åˆ†ä½œä¸ºæ ‡é¢˜æ˜ å°„
              folder_name = rel_path  # ä¾‹å¦‚ THEYAMLS/Official_Examples
              title = DIR_MAP.get(folder_name, os.path.basename(root_path))

              configs_data = {} 
              
              for f in sorted(files):
                  if f.lower().endswith((".yaml", ".yml")) and f not in IGNORE_FILES:
                      full_path = os.path.join(root_path, f)
                      parsed_info = analyze_single_config(full_path)
                      
                      if parsed_info:
                          configs_data[f] = {
                              "file_size": get_file_size(full_path),
                              "parsed": parsed_info
                          }

              content = []
              content.append(f"# ğŸ“‚ {title}\n")
              
              depth = rel_path.count(os.sep) + 1
              back_link = "../" * depth + "README.md"
              content.append(f"[ğŸ”™ è¿”å›ä¸»é¡µ (Return to Home)]({back_link})\n")
              content.append("> ğŸ¤– **è‡ªåŠ¨åˆ†ææŠ¥å‘Š** | Auto-generated Report\n")

              if len(configs_data) > 1:
                  content.append("## âš”ï¸ é…ç½®æ¨ªå‘å¯¹æ¯” (Comparison)\n")
                  content.append(generate_comparison_table(configs_data))
                  content.append("\n")
              
              if configs_data:
                  content.append("## ğŸ“„ é…ç½®æ–‡ä»¶è¯¦è§£ (Details)\n")
                  for filename, data in configs_data.items():
                      info = data.get("parsed", {})
                      file_url = f"{REPO_URL}/{urllib.parse.quote(rel_path)}/{urllib.parse.quote(filename)}"
                      
                      content.append(f"### ğŸ“ {filename}")
                      content.append(f"- **å¤§å°**: {data.get('file_size', 'N/A')}")
                      content.append(f"- **é“¾æ¥**: [æŸ¥çœ‹æºç ]({file_url})")

                      port_lines = info.get("ports_display_lines", [])
                      if port_lines:
                          content.append(f"\n#### ğŸ“¶ ç½‘ç»œç«¯å£é…ç½® (Ports)")
                          content.append("| ç±»å‹ | ç«¯å£/åœ°å€ | è¯´æ˜ |")
                          content.append("| :--- | :--- | :--- |")
                          for line in port_lines:
                              content.append(line)
                          content.append("\n")

                      groups_raw = info.get("groups_raw", [])
                      if groups_raw:
                          group_count = info.get("group_count", 0)
                          content.append(f"<details>")
                          content.append(f"<summary><b>ğŸ” ç‚¹å‡»æŸ¥çœ‹ç­–ç•¥ç»„æ¶æ„ ({group_count}ä¸ª)</b></summary>\n")
                          content.append("| ç­–ç•¥ç»„ (Group) | ç±»å‹ (Type) |")
                          content.append("| :--- | :--- |")
                          content.extend(groups_raw[:15])
                          if len(groups_raw) > 15:
                              content.append(f"| ... | è¿˜æœ‰ {len(groups_raw)-15} ä¸ª |")
                          content.append(f"\n</details>\n")
                      
                      dns_raw = info.get("dns_raw", [])
                      if dns_raw:
                          content.append(f"<details>")
                          content.append(f"<summary><b>ğŸŒ ç‚¹å‡»æŸ¥çœ‹ DNS é…ç½®</b></summary>\n")
                          content.append("| ç±»å‹ | æœåŠ¡å™¨ |")
                          content.append("| :--- | :--- |")
                          content.extend(dns_raw)
                          content.append(f"\n</details>\n")
                      
                      content.append("\n---\n")

              content.append("## ğŸ“¦ æ‰€æœ‰æ–‡ä»¶åˆ—è¡¨ (File List)\n")
              content.append("| æ–‡ä»¶å | å¤§å° | é“¾æ¥ |")
              content.append("| :--- | :--- | :--- |")
              for f in sorted(files):
                  if f in IGNORE_FILES or f.startswith("."): continue
                  f_path = os.path.join(root_path, f)
                  f_url = f"{REPO_URL}/{urllib.parse.quote(rel_path)}/{urllib.parse.quote(f)}"
                  content.append(f"| `{f}` | {get_file_size(f_path)} | [æŸ¥çœ‹]({f_url}) |")

              return "\n".join(content)

          print("Starting README generation...")
          # æ‰«æ THEYAMLS ä¸‹çš„ç›´æ¥å­ç›®å½•
          if os.path.exists("THEYAMLS"):
              for category in os.listdir("THEYAMLS"):
                  category_path = os.path.join("THEYAMLS", category)
                  if os.path.isdir(category_path):
                      files = os.listdir(category_path)
                      if any(f.endswith((".yaml", ".yml")) for f in files):
                          readme_txt = generate_readme(category_path, files)
                          with open(os.path.join(category_path, "README.md"), "w", encoding="utf-8") as f:
                              f.write(readme_txt)
                          print(f"Generated: THEYAMLS/{category}/README.md")
          PYTHON_SCRIPT

      - name: Generate OpenClash Configs
        run: |
          python3 << 'PYTHON_SCRIPT'
          import os
          import yaml
          from urllib.parse import quote

          # ä¿®æ”¹ï¼šæºç›®å½•æ”¹ä¸º THEYAMLS ä¸‹çš„åˆ†ç±»
          SOURCE_BASE = "THEYAMLS"
          SOURCE_DIRS = [
              "THEYAMLS/Official_Examples",
              "THEYAMLS/General_Config", 
              "THEYAMLS/Smart_Mode",
              "THEYAMLS/Mobile_Modules"
          ]
          # ä¿®æ”¹ï¼šè¾“å‡ºåˆ° Overwrite/THEOPENCLASH
          OUTPUT_BASE = "Overwrite/THEOPENCLASH"
          GITHUB_REPO = "${{ github.repository }}"
          REPO_RAW_BASE = f"https://raw.githubusercontent.com/{GITHUB_REPO}/main"
          IGNORE_FILES = ["README.md", "LICENSE", "release_body.md"]
          
          yaml.add_multi_constructor("!", lambda loader, suffix, node: None, Loader=yaml.SafeLoader)

          def parse_yaml_file(file_path):
              try:
                  with open(file_path, "r", encoding="utf-8") as f:
                      content = f.read()
                  
                  if "\t" in content:
                      content = content.replace("\t", "  ")
                  
                  data = yaml.safe_load(content)
                  if not isinstance(data, dict):
                      return {"providers": [], "has_providers": False}
                  
                  providers_dict = data.get("proxy-providers", {})
                  if not isinstance(providers_dict, dict) or not providers_dict:
                      return {"providers": [], "has_providers": False}
                  
                  provider_names = list(providers_dict.keys())
                  return {
                      "providers": provider_names,
                      "has_providers": len(provider_names) > 0
                  }
              except Exception as e:
                  print(f"âš ï¸ Parse failed {file_path}: {e}")
                  return {"providers": [], "has_providers": False}

          def generate_conf_content(filename, raw_url, providers):
              lines = []
              lines.append("# --- OpenClash Overwrite Config ---")
              lines.append(f"# Source: {filename}")
              lines.append(f"# Generated: Auto-generated by GitHub Actions")
              lines.append("")
              lines.append("[General]")
              lines.append("DISABLE_UDP_QUIC = 1")
              lines.append("")
              lines.append(f"DOWNLOAD_FILE = url={raw_url}, path=/etc/openclash/config/{filename}, cron=0 6 * * *, force=false")
              lines.append("")
              lines.append(f"CONFIG_FILE = /etc/openclash/config/{filename}")
              lines.append("")
              lines.append("SUB_INFO_URL = $EN_KEY1")
              lines.append("")
              lines.append("[Overwrite]")
              lines.append("# EN_KEY: Environment variables for subscription URLs. EN_KEY1=URL1;EN_KEY2=URL2...")
              
              if providers:
                  for idx, provider_name in enumerate(providers, start=1):
                      line = f'ruby_map_edit "$CONFIG_FILE" "[\'proxy-providers\']" "{provider_name}" "[\'url\']" "$EN_KEY{idx}"'
                      lines.append(line)
              else:
                  lines.append("# No proxy-providers detected, no URL overwrite needed")
              
              return "\n".join(lines)

          def scan_and_generate():
              print("=" * 70)
              print("OpenClash Config Generator")
              print("=" * 70)
              
              total_generated = 0
              total_skipped = 0
              
              for source_dir in SOURCE_DIRS:
                  if not os.path.exists(source_dir):
                      print(f"âš ï¸ Directory not found: {source_dir}")
                      continue
                  
                  print(f"\nğŸ“‚ Processing: {source_dir}")
                  
                  for root, dirs, files in os.walk(source_dir):
                      dirs[:] = [d for d in dirs if not d.startswith(".")]
                      
                      for filename in files:
                          if filename in IGNORE_FILES or not filename.endswith((".yaml", ".yml")):
                              continue
                          
                          file_path = os.path.join(root, filename)
                          parsed = parse_yaml_file(file_path)
                          
                          if not parsed["has_providers"]:
                              print(f"â„¹ï¸ Skip (no providers): {file_path}")
                              total_skipped += 1
                              continue
                          
                          # è®¡ç®—ç›¸å¯¹è·¯å¾„ (ç›¸å¯¹äº THEYAMLS)
                          rel_path = os.path.relpath(root, SOURCE_BASE)
                          # æ„å»º Raw URL (æŒ‡å‘ THEYAMLS)
                          raw_url = f"{REPO_RAW_BASE}/{SOURCE_BASE}/{rel_path.replace(os.sep, '/')}/{quote(filename)}"
                          
                          # è¾“å‡ºè·¯å¾„ä¿æŒåŸåˆ†ç±»ç»“æ„
                          output_dir = os.path.join(OUTPUT_BASE, rel_path)
                          os.makedirs(output_dir, exist_ok=True)
                          
                          conf_filename = os.path.splitext(filename)[0] + ".conf"
                          output_path = os.path.join(output_dir, conf_filename)
                          
                          conf_content = generate_conf_content(filename, raw_url, parsed["providers"])
                          
                          with open(output_path, "w", encoding="utf-8") as f:
                              f.write(conf_content)
                          
                          print(f"âœ… Generated: {output_path}")
                          total_generated += 1
              
              print("\n" + "=" * 70)
              print(f"âœ… Success: {total_generated} configs")
              print(f"â­ï¸ Skipped: {total_skipped} files")
              print("=" * 70)

          scan_and_generate()
          PYTHON_SCRIPT

      - name: Generate OpenClash Overview READMEs
        run: |
          python3 << 'PYTHON_SCRIPT'
          import os
          
          # ä¿®æ”¹ï¼šåŸºç¡€è·¯å¾„æ”¹ä¸º Overwrite/THEOPENCLASH
          OUTPUT_BASE = "Overwrite/THEOPENCLASH"
          CATEGORY_DESC = {
              "Official_Examples": "Mihomo Official Examples",
              "General_Config": "General Configs - For daily use",
              "Smart_Mode": "Smart Mode - For routers",
              "Mobile_Modules": "Mobile Modules - For rooted Android"
          }
          
          def generate_category_readme(category_path, category_name):
              files = []
              for root, dirs, filenames in os.walk(category_path):
                  for filename in filenames:
                      if filename.endswith(".conf"):
                          rel_path = os.path.relpath(os.path.join(root, filename), category_path)
                          files.append(rel_path)
              
              if not files:
                  return
              
              lines = []
              lines.append(f"# ğŸ“ {category_name}")
              lines.append("")
              lines.append(f"> {CATEGORY_DESC.get(category_name, 'Config List')}")
              lines.append("")
              lines.append("## ğŸ“‹ Config Files")
              lines.append("")
              lines.append("| File Path | Description |")
              lines.append("| :--- | :--- |")
              
              for file_path in sorted(files):
                  lines.append(f"| `{file_path}` | OpenClash Overwrite Config |")
              
              lines.append("")
              lines.append("## ğŸ“– Usage")
              lines.append("")
              lines.append("1. Open OpenClash Plugin -> Config Subscribe")
              lines.append("2. Paste the Raw URL of the `.conf` file")
              lines.append("3. Set env variables `EN_KEY1`, `EN_KEY2`... to your subscription URLs")
              lines.append("4. Save and Update")
              lines.append("")
              lines.append("[ğŸ”™ Back to Main](../README.md)")
              
              readme_path = os.path.join(category_path, "README.md")
              with open(readme_path, "w", encoding="utf-8") as f:
                  f.write("\n".join(lines))
              
              print(f"âœ… Generated README: {readme_path}")
          
          if os.path.exists(OUTPUT_BASE):
              for category in os.listdir(OUTPUT_BASE):
                  category_path = os.path.join(OUTPUT_BASE, category)
                  if os.path.isdir(category_path):
                      generate_category_readme(category_path, category)
              
              main_lines = []
              main_lines.append("# ğŸ“¦ OpenClash Overwrite Configurations")
              main_lines.append("")
              main_lines.append("> ğŸ¤– **Auto-generated** from THEYAMLS repository configs")
              main_lines.append("")
              main_lines.append("## ğŸ“‚ Categories")
              main_lines.append("")
              
              for category in sorted(os.listdir(OUTPUT_BASE)):
                  category_path = os.path.join(OUTPUT_BASE, category)
                  if os.path.isdir(category_path):
                      desc = CATEGORY_DESC.get(category, "Configs")
                      main_lines.append(f"- ğŸ“ **[{category}](./{category}/README.md)** - {desc}")
              
              main_lines.append("")
              main_lines.append("## ğŸš€ Quick Start")
              main_lines.append("")
              main_lines.append("1. Select category and find your config")
              main_lines.append("2. Click `.conf` file to get Raw URL")
              main_lines.append("3. Add to OpenClash Config Subscribe")
              main_lines.append("4. Set environment variables and apply")
              main_lines.append("")
              main_lines.append("[ğŸ  Back to Project](../../README.md)")
              
              main_readme = os.path.join(OUTPUT_BASE, "README.md")
              with open(main_readme, "w", encoding="utf-8") as f:
                  f.write("\n".join(main_readme))
              print(f"âœ… Generated main README: {main_readme}")
          PYTHON_SCRIPT

      - name: Commit and Push
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "41898282+github-actions[bot]@users.noreply.github.com"
          
          git add .
          if git diff --staged --quiet; then
            echo "âœ… No changes detected. Exiting."
            exit 0
          fi
          
          git commit -m "ğŸ¤– Auto: Generate docs & OpenClash configs $(date +'%Y-%m-%d')"
          git pull origin ${{ github.ref_name }} --rebase --autostash
          git push origin HEAD:${{ github.ref_name }}
